use std::str::FromStr;

use ast;

grammar;

pub Noise: ast::Token = {
    "find" <OrBoolObject>
};

KeyValue: ast::Token = {
    // This one recurses down nested objects
    <key:Literal> ":" <value:BoostHelper<Object>> => {
        ast::Token::Object(key, Box::new(value))
    },
    // This matches an object where the value is an array
    <key:Literal> ":" <bind:Bind?> <value:BoostHelper<Array>> => {
        match bind {
            Some(bb) => ast::Token::Object(key, Box::new(ast::Token::Bind(bb, Box::new(value)))),
            None => ast::Token::Object(key, Box::new(value))
        }
    },
    // This matches once we hit an operator within an object or array
    BoostHelper<KeyOperatorValue>,
    // Allow parenthesis
    BoostHelper<Parenthesis>,
};

KeyOperatorValue: ast::Token = {
    // Within an array the operator might not have a key
    <key:(<Literal> ":")?> <op:Operator> <value:JsonPrimitive> => {
        match op {
            ast::OperatorType::Equal => ast::Token::Equal(key, Box::new(value)),
            ast::OperatorType::Greater => ast::Token::Greater(key, Box::new(value)),
            ast::OperatorType::GreaterEqual => ast::Token::GreaterEqual(key, Box::new(value)),
            // TODO vmx 2017-11-08: Make this a proper error instead of a panic
            ast::OperatorType::Intersect => panic!("error: bounding box operator needs a proper bounding box [W, S, E, N] as value"),
            ast::OperatorType::Less => ast::Token::Less(key, Box::new(value)),
            ast::OperatorType::LessEqual => ast::Token::LessEqual(key, Box::new(value)),
            ast::OperatorType::WordMatch => ast::Token::WordMatch(key, Box::new(value)),
        }
    },
    <key:(<Literal> ":")?> "&&" <bbox:Bbox> => {
        ast::Token::Intersect(key, Box::new(bbox))
    },
};

Parenthesis: ast::Token = {
    "(" <OrBool> ")"
};

Object: ast::Token = {
    "{" <OrBool> "}"
};

Array: ast::Token = {
    // Arrays can contain objects...
    "[" <BoostHelper<Object>> "]" => ast::Token::Array(Box::new(<>)),
    // ...or operators
    "[" <OrBool> "]" => ast::Token::Array(Box::new(<>)),
};

Bind: String = {
    // TODO vmx 2017-11-08: Match bind variable name as implemented in the current parser
    <r#"\w+"#> "::" => String::from(<>)
};

Literal: String = {
    // TODO vmx 2017-11-03: Match literal as implemented in the current parser (with escaping)
    <with_quotes:r#""[\w\.]+""#> => String::from(&with_quotes[1..with_quotes.len() - 1]),
};

Number: f64 = {
    // TODO vmx 2017-11-08: Match numbers as in the JSON spec
    r"[0-9]+\.[0-9]+" => f64::from_str(<>).unwrap(),
    r"[0-9]+" => f64::from_str(<>).unwrap(),
};

JsonPrimitive: ast::Token = {
    "null" => ast::Token::JsonNull,
    "false" => ast::Token::JsonBool(false),
    "true" => ast::Token::JsonBool(true),
    Number => ast::Token::JsonNumber(<>),
    Literal => ast::Token::JsonString(<>),
};

Bbox: ast::Token = {
    "[" <ww:Number> "," <ss:Number> "," <ee:Number> "," <nn:Number> "]" => {
        ast::Token::Bbox(ww, ss, ee, nn)
    }
};

Boost: u64 = {
    // TODO vmx 2017-11-07: Add proper error handling
    "^" <r"[0-9]+"> => u64::from_str(<>).unwrap()
};

// Returns a token wrapped in a boost if there was one
BoostHelper<T>: T = {
    <token:T> <boost:Boost?> => {
        match boost {
            Some(bb) => ast::Token::Boost(bb, Box::new(token)),
            None => token,
        }
    }
};


Operator: ast::OperatorType = {
    "&&" => ast::OperatorType::Intersect,
    "==" => ast::OperatorType::Equal,
    ">" => ast::OperatorType::Greater,
    ">=" => ast::OperatorType::GreaterEqual,
    "<" => ast::OperatorType::Less,
    "<=" => ast::OperatorType::LessEqual,
    "~=" => ast::OperatorType::WordMatch,
};


// Booleans within objects/arrays
AndBool = Bool<AndBoolOp, KeyValue>;
OrBool = Bool<OrBoolOp, AndBool>;

// Boolean for top-level objects
AndBoolObject = Bool<AndBoolOp, BoostHelper<Object>>;
OrBoolObject = Bool<OrBoolOp, AndBoolObject>;

AndBoolOp: ast::BoolType = {
    "," => ast::BoolType::And,
    "&&" => ast::BoolType::And,
};

OrBoolOp: ast::BoolType = {
    "||" => ast::BoolType::Or,
};

Bool<BoolOp, NextBool>: ast::Token = {
  <left:Bool<BoolOp, NextBool>> <op:BoolOp> <right:NextBool> => {
     match op {
         ast::BoolType::And => ast::Token::And(Box::new(left), Box::new(right)),
         ast::BoolType::Or => ast::Token::Or(Box::new(left), Box::new(right)),
     }
  },
  NextBool,
};


match {
    r"[0-9]+"
} else {
    _
}
