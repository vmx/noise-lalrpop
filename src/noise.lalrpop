use std::str::FromStr;

use ast;

grammar;

pub Noise: ast::Token = {
    <find:Find> <order:Order?> <ret:Return?> <limit:Limit?> => {
        ast::Token::Noise(Box::new(find), order.unwrap_or(Vec::new()), Box::new(ret),
                          Box::new(limit))
    }
};

Find: ast::Token = {
    "find" "{}" => ast::Token::All,
    "find" <OrBoolObject>,
};

KeyValue: ast::Token = {
    // This one recurses down nested objects
    <key:Literal> ":" <value:NotHelper<BoostHelper<Object>>> => {
        ast::Token::Object(key, Box::new(value))
    },
    // This matches an object where the value is an array
    <key:Literal> ":" <bind:Bind?> <value:BoostHelper<Array>> => {
        match bind {
            Some(bb) => ast::Token::Object(key, Box::new(ast::Token::Bind(bb, Box::new(value)))),
            None => ast::Token::Object(key, Box::new(value))
        }
    },
    // This matches once we hit an operator within an object or array
    BoostHelper<KeyOperatorValue>,
    // Allow parenthesis
    BoostHelper<Parenthesis>,
};

KeyOperatorValue: ast::Token = {
    // Within an array the operator might not have a key
    <key:(<Literal> ":")?> <op:Operator> <value:JsonPrimitive> => {
        match op {
            ast::OperatorType::Equal => ast::Token::Equal(key, Box::new(value)),
            ast::OperatorType::Greater => ast::Token::Greater(key, Box::new(value)),
            ast::OperatorType::GreaterEqual => ast::Token::GreaterEqual(key, Box::new(value)),
            // TODO vmx 2017-11-08: Make this a proper error instead of a panic
            ast::OperatorType::Intersect => panic!("error: bounding box operator needs a proper bounding box [W, S, E, N] as value"),
            ast::OperatorType::Less => ast::Token::Less(key, Box::new(value)),
            ast::OperatorType::LessEqual => ast::Token::LessEqual(key, Box::new(value)),
            ast::OperatorType::NotEqual => ast::Token::Not(Box::new(ast::Token::Equal(key, Box::new(value)))),
            ast::OperatorType::NotWordMatch => ast::Token::Not(Box::new(ast::Token::WordMatch(key, Box::new(value)))),
            ast::OperatorType::WordMatch => ast::Token::WordMatch(key, Box::new(value)),
        }
    },
    <key:(<Literal> ":")?> "&&" <bbox:Bbox> => {
        ast::Token::Intersect(key, Box::new(bbox))
    },
};

Parenthesis: ast::Token = {
    "(" <OrBool> ")"
};

// Parenthesis around top-level objects
ParenthesisObject: ast::Token = {
    "(" <OrBoolObject> ")"
};

Object: ast::Token = {
    "{" <OrBool> "}",
    ParenthesisObject,
};

Array: ast::Token = {
    // Arrays can contain objects...
    "[" <NotHelper<BoostHelper<Object>>> "]" => ast::Token::Array(Box::new(<>)),
    // ...or operators
    "[" <OrBool> "]" => ast::Token::Array(Box::new(<>)),
};

Bind: String = {
    // TODO vmx 2017-11-08: Match bind variable name as implemented in the current parser
    <r"[^\W\d_]+"> "::" => String::from(<>)
};

Literal: String = {
    // TODO vmx 2017-11-03: Match literal as implemented in the current parser (with escaping)
    <with_quotes:r#""[\w\.]+""#> => String::from(&with_quotes[1..with_quotes.len() - 1]),
};

Number: f64 = {
    Float,
    UnsignedInteger => <> as f64,
};

// Based on https://stackoverflow.com/questions/13340717/json-numbers-regular-expression/13340826#13340826
Float: f64 = {
    r"-?(?:0|[1-9]\d*)(?:\.\d+)?(?:[eE][+-]?\d+)?" => f64::from_str(<>).unwrap(),
};

UnsignedInteger: u64 = {
     r"\d+" => u64::from_str(<>).unwrap()
};

JsonPrimitive: ast::Token = {
    "null" => ast::Token::JsonNull,
    "false" => ast::Token::JsonBool(false),
    "true" => ast::Token::JsonBool(true),
    Number => ast::Token::JsonNumber(<>),
    Literal => ast::Token::JsonString(<>),
};

Bbox: ast::Token = {
    "[" <ww:Number> "," <ss:Number> "," <ee:Number> "," <nn:Number> "]" => {
        ast::Token::Bbox(ww, ss, ee, nn)
    }
};

Boost: u64 = {
   "^" <UnsignedInteger>
};

// Returns a token wrapped in a boost if there was one
BoostHelper<T>: T = {
    <token:T> <boost:Boost?> => {
        match boost {
            Some(bb) => ast::Token::Boost(bb, Box::new(token)),
            None => token,
        }
    }
};

Not: () = {
    "!"
};

NotHelper<T>: T = {
    <not:Not?> <token:T> => {
        match not {
            Some(nn) => ast::Token::Not(Box::new(token)),
            None => token,
        }
    }
};

Operator: ast::OperatorType = {
    "&&" => ast::OperatorType::Intersect,
    "==" => ast::OperatorType::Equal,
    ">" => ast::OperatorType::Greater,
    ">=" => ast::OperatorType::GreaterEqual,
    "<" => ast::OperatorType::Less,
    "<=" => ast::OperatorType::LessEqual,
    "!=" => ast::OperatorType::NotEqual,
    "!~=" => ast::OperatorType::NotWordMatch,
    "~=" => ast::OperatorType::WordMatch,
};


// Booleans within objects/arrays
AndBool = Bool<AndBoolOp, KeyValue>;
OrBool = Bool<OrBoolOp, AndBool>;

// Boolean for top-level objects
AndBoolObject = Bool<AndBoolOp, NotHelper<BoostHelper<Object>>>;
OrBoolObject = Bool<OrBoolOp, AndBoolObject>;

AndBoolOp: ast::BoolType = {
    "," => ast::BoolType::And,
    "&&" => ast::BoolType::And,
};

OrBoolOp: ast::BoolType = {
    "||" => ast::BoolType::Or,
};

Bool<BoolOp, NextBool>: ast::Token = {
  <left:Bool<BoolOp, NextBool>> <op:BoolOp> <right:NextBool> => {
     match op {
         ast::BoolType::And => ast::Token::And(Box::new(left), Box::new(right)),
         ast::BoolType::Or => ast::Token::Or(Box::new(left), Box::new(right)),
     }
  },
  NextBool,
};


Order: Vec<ast::Token> = {
    "order" <AscDsc> => vec![ast::Token::Order(<>, Box::new(None))],
    "order" <Comma<OrderCondition>>,
};

OrderCondition: ast::Token = {
    <path:Path> <ascdsc:AscDsc?> => {
        ast::Token::Order(ascdsc.unwrap_or(ast::OrderType::None), Box::new(Some(path)))
    }
};

AscDsc: ast::OrderType = {
    "asc" => ast::OrderType::Asc,
    "dsc" => ast::OrderType::Dsc,
};


Comma<T>: Vec<T> = {
   <items:(<T> ",")*> <last:T?> => match last {
       None => items,
       Some(last) => {
           let mut items = items;
           items.push(last);
           items
       },
   }
};

Return: ast::Token = {
    "return" <ReturnClause>
};

ReturnClause: ast::Token = {
    "{" <ReturnKeyValue> "}",
    "[" <Comma<ReturnClause>> "]" => ast::Token::ReturnArray(<>),
    "." => ast::Token::All,
    Path,
    // TODO vmx 2017-11-08: Match bind variable name as implemented in the current parser
    <bind:r"[^\W\d_]+"> <path:Path?> => ast::Token::ReturnBind(String::from(bind), Box::new(path)),
};

Path: ast::Token = {
    // TODO vmx 2017-11-13: Parse path string the same way the current implementation does
    <path:r"\.([\w\._]+|\[\d*\]?)*"> <default:("default" "=" <Json>)?> => {
       let pp = ast::Token::Path(String::from(path));
       match default {
           Some(dd) => ast::Token::Default(Box::new(dd), Box::new(pp)),
           None => pp,
       }
    }
};

Json: ast::Token = {
   JsonPrimitive,
   "{" <literal:Literal> ":" <json:Json> "}" => ast::Token::JsonObject(literal, Box::new(json)),
   "[" <Comma<Json>> "]" => ast::Token::JsonArray(<>),
};

ReturnKeyValue: ast::Token = {
    <key:Literal> ":" <value:ReturnClause> => {
        ast::Token::Object(key, Box::new(value))
    }
};


Limit: ast::Token = {
    "limit" <UnsignedInteger> => ast::Token::Limit(<>)
};


match {
    // Give unsigned ints a higher priority than floats
    r"\d+"
} else {
    _
}
