use ast;

grammar;

pub Noise: ast::Token = {
    "find" "{" <OrBool> "}"
};

KeyValue: ast::Token = {
    // This one recurses down nested objects
    <key:Literal> ":" <value:Value> => {
        ast::Token::Object(key, Box::new(value))
    },
    // This matches once we hit an operator
    KeyOperatorValue,
};

KeyOperatorValue: ast::Token = {
    <key:Literal> ":" <op:Operator> <value:Literal> => {
        match op {
            ast::OperatorType::Equal => ast::Token::Equal(key, value)
        }
    }
};

Value: ast::Token = {
    "{" <KeyValue> "}",
};

Literal: String = {
    // TODO vmx 2017-11-03: Match literal as implemented in the current parser (with escaping)
    r#"""# <r#"\w+"#> r#"""# => String::from(<>),

};


Operator: ast::OperatorType = {
    "==" => ast::OperatorType::Equal,
};


AndBool = Bool<AndBoolOp, KeyValue>;
OrBool = Bool<OrBoolOp, AndBool>;

AndBoolOp: ast::BoolType = {
    "," => ast::BoolType::And,
};

OrBoolOp: ast::BoolType = {
    "||" => ast::BoolType::Or,
};

Bool<BoolOp, NextBool>: ast::Token = {
  <left:Bool<BoolOp, NextBool>> <op:BoolOp> <right:NextBool> => {
     match op {
         ast::BoolType::And => ast::Token::And(Box::new(left), Box::new(right)),
         ast::BoolType::Or => ast::Token::Or(Box::new(left), Box::new(right)),
     }
  },
  NextBool,
};
